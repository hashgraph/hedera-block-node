/*
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hedera.block.tools.commands.record2blocks.model;

import com.hedera.block.tools.commands.record2blocks.gcp.MainNetBucket;
import com.hedera.hapi.streams.SignatureFile;
import com.hedera.pbj.runtime.ParseException;
import com.hedera.pbj.runtime.io.stream.ReadableStreamingData;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.HexFormat;

/**
 * SignatureFile represents a Hedera record file signature file. There have been 3 versions of the signature files used
 * since OA which are V3, V5 and V6. The below tables describe the content that can be parsed from a record signature
 * file for each version.
 *
 * <table>
 * <caption>Signature File Format V3</caption>
 * <thead>
 * <tr>
 * <th><strong>Name</strong></th>
 * <th><strong>Type (Bytes)</strong></th>
 * <th><strong>Description</strong></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>File Hash Marker</td>
 * <td>byte</td>
 * <td>Value: 4</td>
 * </tr>
 * <tr>
 * <td>File Hash</td>
 * <td>byte[48]</td>
 * <td>SHA384 hash of corresponding *.rcd file</td>
 * </tr>
 * <tr>
 * <td>Signature Marker</td>
 * <td>byte</td>
 * <td>Value: 3</td>
 * </tr>
 * <tr>
 * <td>Length of Signature</td>
 * <td>int (4)</td>
 * <td>Byte size of the following signature bytes</td>
 * </tr>
 * <tr>
 * <td>Signature</td>
 * <td>byte[]</td>
 * <td>Signature bytes</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * <table>
 * <caption>Signature File Format V5</caption>
 * <thead>
 * <tr>
 * <th><strong>Name</strong></th>
 * <th><strong>Type (Bytes)</strong></th>
 * <th><strong>Description</strong></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>Signature File Format Version</td>
 * <td>byte</td>
 * <td>Value: 5</td>
 * </tr>
 * <tr>
 * <tr>
 * <td>Object Stream Signature Version</td>
 * <td>int (4)</td>
 * <td> Value: 1 <br> This defines the format of the remainder of the signature file. This version number is used when parsing a
 * signature file with methods defined in swirlds-common package</td>
 * </tr>
 * <tr>
 * <td>Entire Hash of the corresponding stream file</td>
 * <td>byte[48]</td>
 * <td>SHA384 Hash of the entire corresponding stream file</td>
 * </tr>
 * <tr>
 * <td>Signature on hash bytes of Entire Hash</td>
 * <td>byte[]</td>
 * <td>A signature object generated by signing the hash bytes of Entire Hash. See ` Signature ` table below for
 * details</td>
 * </tr>
 * <tr>
 * <td>Metadata Hash of the corresponding stream file</td>
 * <td>byte[48]</td>
 * <td>Metadata Hash of the corresponding stream file</td>
 * </tr>
 * <td>Signature on hash bytes of Metadata Hash</td>
 * <td>byte[]</td>
 * <td>A signature object generated by signing the hash bytes of Metadata Hash</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * <table>
 * <caption>Signature File Format V5 - Signature Object</caption>
 * <thead>
 * <tr>
 * <th><strong>Name</strong></th>
 * <th><strong>Type (Bytes)</strong></th>
 * <th><strong>Description</strong></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>Class ID</td>
 * <td>long (8)</td>
 * <td>Value: 0x13dc4b399b245c69</td>
 * </tr>
 * <tr>
 * <tr>
 * <td>Class Version</td>
 * <td>int (4)</td>
 * <td>Value: 1 </td>
 * </tr>
 * <tr>
 * <td>SignatureType</td>
 * <td>int (4)</td>
 * <td>Value: 1 - Denotes SHA384withRSA</td>
 * </tr>
 * <tr>
 * <td>Length of Signature</td>
 * <td>int (4)</td>
 * <td>Size of the signature in bytes</td>
 * </tr>
 * <tr>
 * <td>CheckSum</td>
 * <td>int (4)</td>
 * <td>101 - length of signature bytes</td>
 * </tr>
 * <td>Signature bytes</td>
 * <td>byte[]</td>
 * <td>Serialized Signature bytes</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * <table>
 * <caption>Signature File Format V6</caption>
 * <thead>
 * <tr>
 * <th><strong>Name</strong></th>
 * <th><strong>Type (Bytes)</strong></th>
 * <th><strong>Description</strong></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>Signature File Format Version</td>
 * <td>byte</td>
 * <td>Value: 6</td>
 * </tr>
 * <tr>
 * <td>Protobuf Encoded</td>
 * <td>byte[]</td>
 * <td>Rest of signature file is a protobuf serialized message of type com.hedera.hapi.streams.SignatureFile</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * @param nodeId Node ID of the node that signed the file
 * @param fileHash SHA384 hash of corresponding *.rcd file
 * @param signature Signature bytes or RSA signature of the file hash, signed by the node's private key
 */
public record ParsedSignatureFile(int nodeId, byte[] fileHash, byte[] signature) {
    /**
     * The marker for the file hash in a V3 signature file. This is the first byte so also acts like a version number.
     */
    public static final byte V2_FILE_HASH_MARKER = 4;

    public static final byte FILE_VERSION_5 = 5;
    public static final byte FILE_VERSION_6 = 6;
    public static final byte V3_SIGNATURE_MARKER = 3;

    /**
     * toString for debugging, prints the file hash and signature in hex format.
     *
     * @return the string representation of the SignatureFile
     */
    @Override
    public String toString() {
        final HexFormat hexFormat = HexFormat.of();
        return "SignatureFile[" + "nodeId="
                + nodeId + ", " + "fileHash="
                + hexFormat.formatHex(fileHash) + ", signature="
                + hexFormat.formatHex(signature) + ']';
    }

    /**
     * Download and parse a SignatureFile from a ChainFile.
     *
     * @param signatureChainFile the chain file for the signature file
     * @param mainNetBucket the bucket to download from
     * @return the parsed SignatureFile
     */
    public static ParsedSignatureFile downloadAndParse(ChainFile signatureChainFile, MainNetBucket mainNetBucket) {
        // first download
        try (DataInputStream in = new DataInputStream(signatureChainFile.downloadStreaming(mainNetBucket))) {
            // extract node ID from file path. This depends on the fixed relationship between node account ids and node
            // ids.
            final int nodeId = signatureChainFile.nodeAccountId() - 3;
            // now parse
            final int firstByte = in.read();
            // the first byte is either the file hash marker or a version number in V6 record stream
            switch (firstByte) {
                case V2_FILE_HASH_MARKER:
                    final byte[] fileHash = new byte[48];
                    in.readFully(fileHash);
                    if (in.read() != V3_SIGNATURE_MARKER) {
                        throw new IllegalArgumentException("Invalid signature marker");
                    }
                    final int signatureLength = in.readInt();
                    final byte[] signature = new byte[signatureLength];
                    in.readFully(signature);
                    return new ParsedSignatureFile(nodeId, fileHash, signature);
                case FILE_VERSION_5:
                    // check the object stream signature version should be 1
                    if (in.readInt() != 1) {
                        throw new IllegalArgumentException("Invalid object stream signature version");
                    }
                    // read hash object - hash bytes
                    final byte[] entireFileHash = readHashObject(in);
                    // read signature object - class id
                    if (in.readLong() != 0x13dc4b399b245c69L) {
                        throw new IllegalArgumentException("Invalid signature object class ID");
                    }
                    // read signature object - class version
                    if (in.readInt() != 1) {
                        throw new IllegalArgumentException("Invalid signature object class version");
                    }
                    // read signature object - signature type - An RSA signature as specified by the FIPS 186-4
                    if (in.readInt() != 1) {
                        throw new IllegalArgumentException("Invalid signature type");
                    }
                    // read signature object - length of signature
                    final int signatureLengthV5 = in.readInt();
                    // read and check signature object - checksum
                    if (in.readInt() != 101 - signatureLengthV5) {
                        throw new IllegalArgumentException("Invalid checksum");
                    }
                    // read signature object - signature bytes
                    final byte[] signatureV5 = new byte[signatureLengthV5];
                    in.readFully(signatureV5);
                    // we only care about the file metadata hash and the signature so can stop parsing here
                    return new ParsedSignatureFile(nodeId, entireFileHash, signatureV5);
                case FILE_VERSION_6:
                    // everything from here on is protobuf encoded
                    try {
                        SignatureFile signatureFile = SignatureFile.PROTOBUF.parse(new ReadableStreamingData(in));
                        if(signatureFile.fileSignature() == null) {
                            throw new IllegalArgumentException("Invalid signature file, missing file signature");
                        }
                        if (signatureFile.fileSignature().hashObject() == null) {
                            throw new IllegalArgumentException("Invalid signature file, missing hash object");
                        }
                        return new ParsedSignatureFile(
                                nodeId,
                                signatureFile
                                        .fileSignature()
                                        .hashObject()
                                        .hash()
                                        .toByteArray(),
                                signatureFile.fileSignature().signature().toByteArray());
                    } catch (ParseException e) {
                        throw new RuntimeException("Error protobuf parsing V6 signature file", e);
                    }
                default:
                    throw new IllegalArgumentException("Invalid first byte [" + firstByte + "] expected "
                            + V2_FILE_HASH_MARKER + " or " + FILE_VERSION_6);
            }
        } catch (IOException e) {
            throw new RuntimeException("Error downloading or parsing signature file", e);
        }
    }

    /** The size of a hash object in bytes */
    public static final int HASH_OBJECT_SIZE_BYTES = Long.BYTES + Integer.BYTES + Integer.BYTES + Integer.BYTES + 48;

    /**
     * Read a hash object from a data input stream in SelfSerializable SHA384 format.
     *
     * @param in the data input stream
     * @return the hash bytes
     * @throws IOException if an error occurs reading the hash object
     */
    public static byte[] readHashObject(DataInputStream in) throws IOException {
        // read hash class id
        if (in.readLong() != 0xf422da83a251741eL) {
            throw new IllegalArgumentException("Invalid hash class ID");
        }
        // read hash class version
        if (in.readInt() != 1) {
            throw new IllegalArgumentException("Invalid hash class version");
        }
        // read hash object, starting with digest type SHA384
        if (in.readInt() != 0x58ff811b) {
            throw new IllegalArgumentException("Invalid digest type not SHA384");
        }
        // read hash object - length of hash
        if (in.readInt() != 48) {
            throw new IllegalArgumentException("Invalid hash length");
        }
        // read hash object - hash bytes
        final byte[] entireFileHash = new byte[48];
        in.readFully(entireFileHash);
        return entireFileHash;
    }
}
