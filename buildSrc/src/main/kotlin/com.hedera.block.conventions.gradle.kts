/*
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.adarshr.gradle.testlogger.theme.ThemeType

plugins {
    id("java")
    id("jacoco")
    id("org.gradlex.java-module-dependencies")
    id("com.adarshr.test-logger")
    id("com.hedera.block.repositories")
    id("com.hedera.block.jpms-modules")
    id("com.hedera.block.spotless-conventions")
    id("com.hedera.block.spotless-java-conventions")
    id("com.hedera.block.spotless-kotlin-conventions")
    id("com.hedera.block.maven-publish")
}

group = "com.hedera.block"

val javaVersionMajor = JavaVersion.VERSION_21
val javaVersionPatch = "0.4"

val currentJavaVersionMajor = JavaVersion.current()
val currentJavaVersion = providers.systemProperty("java.version").get()
val expectedJavaVersion = "$javaVersionMajor.$javaVersionPatch"

if (currentJavaVersion != expectedJavaVersion) {
    val message =
        "Gradle runs with Java $currentJavaVersion. This project works best running with Java $expectedJavaVersion. " +
            "\n - From commandline: change JAVA_HOME and/or PATH to point at Java $expectedJavaVersion installation." +
            "\n - From IntelliJ: change 'Gradle JVM' in 'Gradle Settings' to point at Java $expectedJavaVersion installation."

    if (currentJavaVersionMajor.ordinal < javaVersionMajor.ordinal) { // fail if version is too old
        throw (RuntimeException(message))
    } else {
        logger.lifecycle("WARN: $message")
    }
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
        vendor.set(JvmVendorSpec.ADOPTIUM)
    }

    // Enable JAR file generation required for publishing
    withJavadocJar()
    withSourcesJar()
}

testing {
    @Suppress("UnstableApiUsage") suites.getByName<JvmTestSuite>("test") { useJUnitJupiter() }
}

tasks.withType<AbstractArchiveTask> {
    isPreserveFileTimestamps = false
    isReproducibleFileOrder = true
    filePermissions { unix("0664") }
    dirPermissions { unix("0775") }
}

val deactivatedCompileLintOptions =
    listOf(
        // In Gradle, a module does not see the upstream (not-yet-compiled) modules. This could
        // only be solved by calling 'javac' with '--source-module-path' to make other sources
        // known. But this is at odds with how Gradle's incremental compilation calls the
        // compiler for a subset of Java files for each project individually.
        "module", // module not found when doing 'exports to ...'
        "serial", // serializable class ... has no definition of serialVersionUID
        "processing", // No processor claimed any of these annotations: ...
        "try", // auto-closeable resource ignore is never referenced... (AutoClosableLock)
        "missing-explicit-ctor", // class ... declares no explicit constructors

        // Needed because we use deprecation internally and do not fix all uses right away
        "removal",
        "deprecation",

        // The following checks could be activated and fixed:
        "this-escape", // calling public/protected method in constructor
        "overrides", // overrides equals, but neither it ... overrides hashCode method
        "unchecked",
        "rawtypes"
    )

tasks.withType<JavaCompile>().configureEach {
    // Track the full Java version as input (e.g. 17.0.3 vs. 17.0.9).
    // By default, Gradle only tracks the major version as defined in the toolchain (e.g. 17).
    // Since the full version is encoded in 'module-info.class' files, it should be tracked as
    // it otherwise leads to wrong build cache hits.
    inputs.property("fullJavaVersion", currentJavaVersion)

    options.encoding = "UTF-8"
    options.isFork = true // run compiler in separate JVM process (independent of toolchain setup)
    options.compilerArgs.add("-implicit:none")

    doLast {
        // Make sure consistent line ending are used in files generated by annotation processors by
        // rewriting generated files.
        // To fix this problem at the root, one of these issues needs to be addressed upstream:
        // - https://github.com/google/auto/issues/1656
        // - https://github.com/gradle/gradle/issues/27385
        if (System.lineSeparator() != "\n") {
            destinationDirectory
                .get()
                .asFileTree
                .filter { it.extension != "class" }
                .forEach {
                    val content = it.readText()
                    val normalizedContent = content.replace(System.lineSeparator(), "\n")
                    if (content != normalizedContent) {
                        it.writeText(normalizedContent)
                    }
                }
        }
    }
}

tasks.withType<Javadoc>().configureEach {
    options {
        this as StandardJavadocDocletOptions
        encoding = "UTF-8"
        tags(
            "apiNote:a:API Note:",
            "implSpec:a:Implementation Requirements:",
            "implNote:a:Implementation Note:"
        )
        options.windowTitle = "Hedera Block Node"
        options.memberLevel = JavadocMemberLevel.PACKAGE
        // Commenting this so we still get missing javadocs warnings
        // addStringOption("Xdoclint:all,-missing", "-Xwerror")
    }
}

testlogger {
    theme = ThemeType.MOCHA
    slowThreshold = 10000
    showStandardStreams = true
    showPassedStandardStreams = false
    showSkippedStandardStreams = false
    showFailedStandardStreams = true
}

// Ensure JaCoCo coverage is generated and aggregated
tasks.jacocoTestReport.configure {
    reports {
        xml.required.set(true)
        html.required.set(true)
    }

    val testExtension = tasks.test.get().extensions.getByType<JacocoTaskExtension>()
    executionData.setFrom(testExtension.destinationFile)

    shouldRunAfter(tasks.named("check"))
}

tasks.check {
    // Ensure the check task also runs the JaCoCo coverage report
    dependsOn(tasks.jacocoTestReport)
    // Check dependency scopes in module-info.java
    dependsOn(tasks.checkAllModuleInfo)
}
